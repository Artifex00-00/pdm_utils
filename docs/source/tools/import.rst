Import genome annotations
=========================


In general, data pertaining to a complete phage genome is managed within a Phamerator database as a discrete unit, in which genome data (such as the PhageID, genome sequence, host data, etc.) is added, removed, and replaced concomitantly with all associated gene annotation data (primarily CDS features), such that any data pertaining to a particular phage in the database has been parsed from one external source, instead of added piecemeal from separate sources or modified within the database after insertion. There are a few fields that are exceptions to this general practice (:ref:`update`)

The ``pdm_utils`` 'import' tool is used to manage the addition, replacement, or removal of genomes::

    > python3 -m pdm_utils import Actino_Draft ./genomes/ ./import_table.csv

This script is a versatile tool for specifically updating the Actino_Draft database, managing different PhameratorDB instances, and supporting the entire SEA-PHAGES annotation pipeline.

First, the script performs a variety of administrative actions on the database in addition to parsing flat files.

Second, it relies on import tickets (such as those generated from the data retrieval step) so that the import process is substantially automated.

Third, it evaluates incoming data, either from parsed flat files or import tickets, with robust quality control (QC) checks that vary depending on the data type, and only proceeds with adding new data to the database once it passes QC.

Fourth, it evaluates and imports data in an interactive environment that provides the database administrator with control over the process. Three arguments are required to run this script [Table 4].






Step 1: parse and validate import table
---------------------------------------

The first step of the import script is to parse and prepare tickets from import_table (:ref:`ticketimport`). The script confirms the table is structured appropriately and that the fields are populated correctly for each ticket type. For each ticket type, there are specific rules regarding how the ticket fields are populated to ensure that the ticket is implemented correctly. For instance, if a new genome is being added with an add ticket, the Phage #2 field should be populated with none; if the add ticket contains a phage name in this field, an error is encountered. Additionally, the script confirms that there are no duplicated tickets or tickets with conflicting data (such as an add and remove ticket for the same phage). After import tickets are parsed and evaluated, they are grouped by ticket type and are ready to be implemented.

The rules governing how import tickets are structured ensure that the tickets are implemented appropriately, but they make it more difficult to construct tickets. Import tickets are automatically generated by the retrieve_data.py script, and it is recommended to rely on this script as much as possible to minimize potential errors. However, import tickets can still be generated manually, and sometimes it may even be necessary (e.g. adding non-SEA-PHAGES genomes from GenBank). Manual creation of tickets for phages that are in PhagesDB can be slightly simplified. The HostStrain, Cluster, Subcluster, and Accession fields can be populated with retrieve. When the script encounters this, it retrieves the requisite data for that specific field directly from PhagesDB, using 'http://phagesdb.org/api/phages/[PhageID]' (in which [PhageID] refers to the specific PhageID from the import ticket).




Step 4: implement add and replace tickets
-----------------------------------------

The largest step in the import script involves implementing these two types of tickets. In this step, the script retrieves all files stored in the genome folder indicated by the second script argument, confirms they have a permissible file extension (gb, gbf, gbk, txt), and confirms that they are a GenBank-formatted flat file that can be parsed [Figure 2]. When new annotations become available for a genome, instead of identifying the exact changes and implementing them in PhameratorDB, all data pertaining to that genome is completely replaced using data from the most up-to-date flat file. This process is slightly more complex than simply deleting the old data and adding the new data, as there are QC checks to ensure that the old genome indicated in the ticket (Phage #2) is indeed the correct genome in the database to be replaced by the new genome (Phage #1). Two types of data are parsed from the flat file and evaluated [Figure 2].

The first type of data relates to the entire phage genome, such as the phage name, nucleotide sequence, host genus, accession, and authorship. The data in the flat file is matched to the import ticket by the phage name parsed from the SOURCE-ORGANISM field at the top of the file, and subsequently evaluated and compared to data in the import ticket and in PhameratorDB. After this, several fields in the Phage table are populated from data derived from the import ticket, from the flat file, or from the script itself [Table 5].


Matching tickets to flat files requires that the phage names are spelled identically. Sometimes this is not the case, in which the desired spelling of the phage name in PhameratorDB (and thus in the import ticket) is slightly differently than the spelling in the GenBank record. These conflicts can arise for several reasons that cannot be immediately corrected. This includes slight variations in nomenclature (such as “phiELB20” versus “ELB20”), inadvertent typos introduced (such as “Fionnbarth” versus “Fionnbharth”), different nomenclature constraints implemented in GenBank (such as “LeBron”, which is spelled “Bron” in the SOURCE-ORGANISM field of the GenBank record), or different nomenclature constraints implemented in PhameratorDB or PhagesDB (such as “ATCC29399B_C” versus “ATCC29399BC”). To account for these conflicts, the import script contains a hard-coded phage name dictionary that converts several GenBank phage names to the desired phage name stored in PhagesDB and the Actino_Draft database. This list contains only ~10-15 name conversions and does not change frequently. An alternative strategy has also been developed that circumvents this issue, in which the phage name is parsed from the filename of the flat file instead of from the SOURCE-ORGANISM field within the record. This allows for greater flexibility when parsing batches of flat files that may not adhere to these default expectations, such as when new PhameratorDB instances are developed for phages that have not been annotated through the SEA-PHAGES program. This option can be implemented using a different run mode (which is discussed in greater detail in the Run Mode section below).

The RetrieveRecord field provides a binary indicator of whether the genome should be automatically updated from GenBank. Initially, this field is indirectly determined by the AnnotationAuthor field. For newly added genomes, if AnnotationAuthor = hatfull, this field is set to 1, otherwise it is set to 0. For genomes being replaced (by automatic updates from GenBank or by the creation of manual tickets), the value in this field is retained.

Several fields in the flat file contain data about the phage and host names: DEFINITION, SOURCE, SOURCE-ORGANISM, and the ORGANISM, HOST, and LAB_HOST sub-fields of the FEATURE-SOURCE field [Figure A-2]. The host and phage name data stored in PhameratorDB is derived from the ticket, but they are compared to the data parsed from these various fields for confirmation.

The second type of data parsed from the flat file pertains to individual genes (and is stored in the Gene table). After parsing the phage genome information, the script iterates through the annotation features in the file. The tRNA and CDS features are evaluated, and all others are ignored.

Currently, tRNA and tmRNA features are not dynamically parsed from flat files and stored in PhameratorDB.

CDS features are parsed and stored in the Gene table, and the script utilizes many QC checks to confirm their integrity. The majority of data that the import script stores in the Gene table are derived directly from the flat file.

The GeneID is the primary key in the Gene table and represents a unique name of the gene in the database. This can be derived three ways. First, it can simply be synonymous with the LOCUS_TAG of the CDS feature in the flat file. For SEA-PHAGES flat files, this is usually the case. However, for non-SEA-PHAGES flat files, there may not be a LOCUS_TAG for every, or any, CDS feature. As a result, the GeneID can be computed on-the-fly by concatenating the PhageID with the CDS count (which indicates the order that the CDS was parsed from the feature list). The import script uses the ticket’s run mode to determine which of these two strategies is implemented. However, neither of these naming strategies guarantee the GeneID is unique in the Gene table, and naming conflicts may arise with features already present in the Gene table. In this case, a warning is issued and a _duplicateID[0123] suffix is appended to the GeneID (where [0123] is an integer).

Gene descriptions are stored in the Notes field of the Gene table. However, CDS features in flat files can contain descriptions in three different fields: PRODUCT, FUNCTION, and NOTE. The Gene description field field in the import ticket indicates which of these three fields are expected to contain gene description data in the flat file. If the script identifies gene descriptions in the other two fields as it parses CDS features, it issues a warning.

The LocusTag field in the Gene table is populated directly from the LOCUS_TAG field in the CDS feature. However, unlike the GeneID field, the LocusTag field does not need to contain unique, non-duplicated values. Storing the LOCUS_TAG data provides an unambiguous link to the original CDS feature in the GenBank record, regardless of the restrictions imposed on the CDS feature’s GeneID. This is valuable when reporting the gene information in a publication, and it is required when requesting GenBank to update information about specific CDS features (such as corrections to coordinates or gene descriptions).

In many GenBank records, CDS features may contain descriptions that are not informative, including “hypothetical protein”, “phage protein”, “unknown”, “conserved hypothetical protein”, ordered numerical data, “gp[0123]” and “ORF[0123]” (where [0123] is an integer), and “putative protein”. These generic descriptions are not retained in PhameratorDB.



Logging database changes
________________________

As QC steps are performed on tickets, the genome either passes or fails QC. When some QC steps are not met, an error is issued. In contrast, when some QC steps are not met, the script pauses and issues a warning, requiring the administrator to indicate whether an error should be issued or not. If a genome acquires one or more errors during import, the entire genome fails to be imported, and no changes are made to the database for that genome. The success or failure of an import ticket has no impact on the success or failure of the next ticket, and the script iterates through all add and replace tickets. After all add and replace tickets are processed, the script is completed. I have created several methods to tracking and managing tickets (and the associated genomes) as they pass or fail QC.

First, a summary of the import process is reported to the user in the UNIX shell during import and after all tickets are processed.

Second, the results of every ticket are recorded in a log file, including any errors and warnings that were generated.

Third, tickets and genome files are moved to new folders based on their import status. All tickets that were successfully implemented with no errors are recorded in a successful_import_table, and the associated genomes are moved to a successful_genomes folder. In contrast, all tickets that failed QC due to one or more errors are recorded in a failed_import_table, and the associated genomes are moved to a failed_genomes folder. This enables quick reference to the specific tickets and genome files that need to be reviewed, modified, and repeated.

Fourth, test and production run types have been created that the administrator can choose between. During a production run, import tickets and genome files are processed and evaluated, and the database is updated as specified by the ticket if QC is passed. In contrast, during a test run, import tickets and genome files are processed and evaluated, but the database is not updated. The test run is a valuable tool to determine whether any particular group of tickets and flat files are ready to be imported without actually altering the database. The import script can be executed on the same tickets and flat files multiple times, each time making the appropriate modifications until the ticket contains no errors. Many SEA-PHAGES annotators now rely on the import script test run to personally evaluate preliminary final annotations prior to uploading them to PhagesDB, and this has helped to improve the speed and efficiency of the PhameratorDB pipeline.

The import script is designed to handle diverse types of tickets present in a single import_table. However, the retrieve_data.py script creates separate staged directories and import tables for different types of data to be imported to minimize potential ticket conflicts. When the import_script.py is executed following the retrieve_data.py script, it is recommended that the script is executed separately for each ticket type, and in the following order: metadata updates, auto-annotated genomes from PECAAN, new preliminary final annotations from PhagesDB, auto-updated SEA-PHAGES final annotations from GenBank, and other miscellaneous tickets that need to be implemented.
