.. _import:

import: manage genome data and annotations
==========================================

In general, data pertaining to a complete phage genome is managed within a MySQL database as a discrete unit, in which genome data (such as the PhageID, genome sequence, host data, etc.) is added, removed, and replaced concomitantly with all associated gene annotation data (primarily CDS features), such that any data pertaining to a particular phage in the database has been parsed from one external source, instead of added piecemeal from separate sources or modified within the database after insertion. There are a few fields that are exceptions to this general practice (:ref:`update`)

The ``pdm_utils`` **import** tool is used to manage the addition, replacement, or removal of genomes::

    > python3 -m pdm_utils import Actino_Draft ./genomes/ ./import_table.csv

This script is a versatile tool for specifically updating the Actino_Draft database, managing different MySQL database instances, and supporting the entire SEA-PHAGES annotation pipeline because it:

    1. relies on import tickets to substantially automate the import process.

    2. performs evaluations to verify the quality of the incoming data.

    3. provides an interactive environment for a more flexible process.



Parse and validate import table
-------------------------------

The first step of **import** is to parse and prepare tickets from the import table (:ref:`ticketimport`). The structure of the table as well as data in each ticket is validated. For each ticket type, there are specific rules regarding how the ticket fields are populated to ensure that the ticket is implemented correctly. For instance, if a new genome is being added with an add ticket, the Secondary PhageID field should be populated with 'none'; if the add ticket contains a phage name in this field, an error is encountered. Additionally, the script confirms that there are no duplicated tickets or tickets with conflicting data (such as an add and remove ticket for the same phage). After import tickets are parsed and evaluated, they are grouped by ticket type and are ready to be implemented.

Import tickets are automatically generated by the 'get_data' tool, but they can also be generated manually (e.g. adding non-SEA-PHAGES genomes from GenBank). Import tickets for phages derived from PhagesDB can be simplified since some data can be directly retrieved from online. The HostStrain, Cluster, Subcluster, and Accession fields can be populated with 'retrieve'. When the script encounters this, it retrieves the requisite data for that specific field directly from PhagesDB.




Process flat files
------------------

After constructing import tickets from the import table, flat files are processed one at a time, matched to the corresponding import ticket, evaluated, and implemented.
For replace tickets, the current genome data in the database is removed and the data from the flat file is parsed and inserted. Two types of data are parsed from the flat file and evaluated: genome-specific and gene-specific data.

Genome-specific data
********************

Genome-level data, such as the phage name, nucleotide sequence, host genus, accession, and authorship is parsed and stored in the *phage* table. The data in the flat file is matched to the import ticket by the phage name parsed from the SOURCE-ORGANISM field at the top of the file, and subsequently evaluated and compared to data in the import ticket and in the database. After this, several fields in the Phage table are populated from data derived from the import ticket or from the flat file.

Matching tickets to flat files requires that the phage names are spelled identically. Sometimes this is not the case, in which the desired spelling of the phage name in the database (and thus in the import ticket) is slightly differently than the spelling in the GenBank record. These conflicts can arise for several reasons that cannot be immediately corrected:

    1. Minor variations in nomenclature (such as “phiELB20” versus “ELB20”)

    2. Inadvertent typos fixed in one database (such as “Fionnbarth” versus “Fionnbharth”)

    3. Different nomenclature constraints implemented in GenBank (such as “LeBron”, which is spelled “Bron” in the SOURCE-ORGANISM field of the GenBank record)

    4. Different nomenclature constraints implemented in the MySQL database or PhagesDB (such as “ATCC29399B_C” versus “ATCC29399BC”)

To account for these conflicts, **import** contains a phage name dictionary that converts several GenBank phage names to the desired phage name stored in PhagesDB and the Actino_Draft database. This list contains nearly two dozen name conversions and does not change frequently. To avoid phage name discrepancies, the phage name can be parsed from the filename of the flat file instead of from the SOURCE-ORGANISM field within the record. This allows for greater flexibility when parsing batches of flat files that may not adhere to these default expectations, such as when new database instances are developed for phages that have not been annotated through the SEA-PHAGES program. This option can be implemented using a different run mode (:ref:`runmodes`).

Several fields in the flat file contain data about the phage and host names: DEFINITION, SOURCE, SOURCE-ORGANISM, and the ORGANISM, HOST, and LAB_HOST sub-fields of the FEATURE-SOURCE field. The host and phage name data stored in the database is derived from the ticket, but they are compared to the data parsed from these various fields for confirmation.


Gene-specific data
******************

The second type of data parsed from the flat file pertains to individual genes (and is stored in the *gene* table). After parsing the genome-specific information, the annotated features are processed. The Source, tRNA, tmRNA, and CDS features are evaluated, and all others are ignored.

.. note::

    Currently, tRNA and tmRNA features are not dynamically parsed from flat files and stored in the MySQL database.

CDS features are parsed, evaluated, and stored in the *gene* table. The majority of data that **import** stores in the *gene* table are derived directly from the flat file. Several things to note:

    1. GeneIDs represent the gene's unique identifier in the database, and is computed one of several ways (:ref:`dbstructure`).

    2. Gene descriptions are stored in the Notes field of the Gene table. However, CDS features in flat files can contain descriptions in three different fields: PRODUCT, FUNCTION, and NOTE. The Gene description field field in the import ticket indicates which of these three fields are expected to contain gene description data in the flat file. If the script identifies gene descriptions in the other two fields as it parses CDS features, it issues a warning.

    3. The LocusTag field in the Gene table is populated directly from the LOCUS_TAG field in the CDS feature. Unlike the GeneID field, the LocusTag field does not need to contain unique, non-duplicated values. Storing the LOCUS_TAG data provides an unambiguous link to the original CDS feature in the GenBank record, regardless of the restrictions imposed on the CDS feature’s GeneID. This is valuable when reporting the gene information in a publication, and it is required when requesting GenBank to update information about specific CDS features (such as corrections to coordinates or gene descriptions).

    4. In many GenBank records, CDS features may contain descriptions that are not informative, including “hypothetical protein”, “phage protein”, “unknown”, “conserved hypothetical protein”, ordered numerical data, “gp<0123>” and “ORF<0123>” (where <0123> is an integer), and “putative protein”. These generic descriptions are not retained.



Evaluations
-----------

As the script iterates through each flat file, it checks numerous fields in the file for accuracy. The script will pause at two types of issues and request input from the user to proceed.

    “Errors”: there are many fields that, if they do not contain the correct information, automatically throws “error” messages, in which the file will not be successfully processed.

    “Warnings”: alternatively, there are many fields that may throw “warnings”, in which there could possibly be a mistake, but the user can indicate this.

Each time the script highlights warnings or errors, it will require input from the user to proceed. The script may ask “Is this correct?”. It is designed such that if the current values are what the user wants, then simply type “yes”. If the script has identified a bona fide mistake, typing “no” will throw an error and the file will not pass review.

A table is printed in the terminal window reporting the information found for each gene (locus tag, descriptions found in the product, function, and note fields, translation table, and the first several amino acids of the translation), as well as what the assigned gene names and gene description will be in the database.


Logging database changes
------------------------

As QC steps are performed on tickets, the genome either passes or fails QC. When some QC steps are not met, an error is issued. In contrast, when some QC steps are not met, data processing pauses and a warning is issued, requiring input to decide whether an error should be issued or not. If a genome acquires one or more errors during import, the entire genome fails to be imported, and no changes are made to the database for that genome. The success or failure of an import ticket has no impact on the success or failure of the next ticket, and all tickets are processed. After all tickets are processed, the **import** is completed.


Several methods of tracking and managing tickets (and the associated genomes) as they pass or fail QC are implemented:

    1. A summary of the import process is reported to the user in the UNIX shell during import and after all tickets are processed.

    2. The results of every ticket are recorded in a log file, including any errors and warnings that were generated. Searching for “warnings” or “errors” in the file can quickly highlight the potential problems.

    3. Tickets and genome files are moved to new folders based on their import status. All tickets that were successfully implemented with no errors are recorded in a 'successful' import table, and the associated genomes are moved to a 'successful' genomes folder. In contrast, all tickets that failed QC due to one or more errors are recorded in a 'failed' import table, and the associated genomes are moved to a 'failed' genomes folder. This enables quick reference to the specific tickets and genome files that need to be reviewed, modified, and repeated.


    4. **import** can be run under 'test' or 'production' mode. During a production run, import tickets and genome files are processed and evaluated, and the database is updated as specified by the ticket if QC is passed. In contrast, during a test run, import tickets and genome files are processed and evaluated, but the database is not updated. The test run can determine if any particular group of tickets and flat files are ready to be imported without actually altering the database. **import** can be executed on the same tickets and flat files multiple times, each time making the appropriate modifications until the ticket contains no errors. This is valuable during the SEA-PHAGES annotation process (:ref:`flatfileqc`).
