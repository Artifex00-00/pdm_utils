"""
Unit tests for functions in phameration.py

Assumes that 'Actino_test' refers to a derivative of Actino_Draft
generated by running the following command in MySQL:

DELETE FROM phage WHERE PhageID NOT LIKE "B%";

This will delete all genomes (and all associated data because of the
cascade hooks) from the database that don't start with a 'B'. Random
choice with no real basis other than simplicity of execution.
"""

from pdm_utils.classes.mysqlconnectionhandler import MySQLConnectionHandler
from pdm_utils.functions.phameration import *
import os
from shutil import rmtree
import unittest


class TestPhamerationFunctions(unittest.TestCase):
    def setUp(self):
        self.handler = MySQLConnectionHandler(username="pdm_anon",
                                              password="pdm_anon",
                                              database="Actino_test")
        self.handler.open_connection()
        self.temp_dir = "/tmp/phamerate"

    def test_1_read_existing_phams(self):
        """Verify we get 2 dictionaries with the same keys back"""
        old_phams, old_colors = read_existing_phams(self.handler)
        # Old phams should be a dict
        with self.subTest():
            self.assertEqual(type(old_phams), type(dict()))
        # Old colors should also be a dict
        with self.subTest():
            self.assertEqual(type(old_colors), type(dict()))
        # Old phams and old colors should have same # of keys
        with self.subTest():
            self.assertEqual(len(old_phams), len(old_colors))
        # Old phams should have 0 keys not in old colors
        with self.subTest():
            self.assertEqual(set(old_phams.keys()) - set(old_colors.keys()),
                             set())
        # Old colors should have 0 keys not in old phams
        with self.subTest():
            self.assertEqual(set(old_colors.keys() - set(old_phams.keys())),
                             set())

    def test_2_read_unphamerated_genes(self):
        """Verify we get back a set of length 0"""
        unphamerated = read_unphamerated_genes(self.handler)
        # Unphamerated should be a set
        with self.subTest():
            self.assertEqual(type(unphamerated), type(set()))
        # Actino_test presently has 0 new genes
        with self.subTest():
            self.assertEqual(len(unphamerated), 0)

    def test_3_get_translations1(self):
        """Verify we get back two dictionaries"""
        gs_to_ts, ts_to_gs = get_translations(self.handler)
        # gs_to_ts should be a dictionary
        with self.subTest():
            self.assertEqual(type(gs_to_ts), type(dict()))
        # ts_to_gs should be a dictionary
        with self.subTest():
            self.assertEqual(type(ts_to_gs), type(dict()))

    def test_3_get_translations2(self):
        """Verify sum of old genes and unphamerated genes is same as total
        number of genes retrieved"""
        old_phams, old_colors = read_existing_phams(self.handler)
        unphamerated = read_unphamerated_genes(self.handler)
        gs_to_ts, ts_to_gs = get_translations(self.handler)
        num_genes_1 = 0
        for i in old_phams.keys():
            num_genes_1 += len(old_phams[i])
        num_genes_2 = len(gs_to_ts)
        self.assertEqual(num_genes_1, num_genes_2)

    def test_4_write_fasta(self):
        """Verify file gets written properly"""
        # refresh temp_dir (so if anything is there it's guaranteed to be
        # there because of this method
        if os.path.exists(self.temp_dir):
            rmtree(self.temp_dir)
        os.makedirs(self.temp_dir)
        filename = f"{self.temp_dir}/input.fasta"
        gs_to_ts, ts_to_gs = get_translations(self.handler)
        write_fasta(ts_to_gs)
        with open(filename, 'r') as fh:
            lines = fh.readlines()

        # there should be 2x as many lines as length of ts_to_gs
        with self.subTest():
            self.assertEqual(len(lines), 2*len(ts_to_gs))
        # every odd-index line (translation) should be a key in ts_to_gs
        for i in range(len(lines)):
            if i % 2 == 1:        # odd-index lines
                with self.subTest():
                    self.assertTrue(lines[i].rstrip("\n") in ts_to_gs.keys())

    def test_5_create_clusterdb1(self):
        """Verify blastclust database gets made"""
        # refresh temp_dir (so if anything is there it's guaranteed to be
        # there because of this method
        refresh_tempdir(self.temp_dir)
        db_file = f"{self.temp_dir}/sequenceDB"
        gs_to_ts, ts_to_gs = get_translations(self.handler)
        write_fasta(ts_to_gs)
        create_clusterdb(program="blast")
        for ext in ["phr", "pin", "psd", "psi", "psq"]:
            with self.subTest():
                self.assertTrue(os.path.exists(f"{db_file}.{ext}"))

    def test_5_create_clusterdb2(self):
        """Verify mmseqs database gets made"""
        # refresh temp_dir (so if anything is there it's guaranteed to be
        # there because of this method
        refresh_tempdir(self.temp_dir)
        db_file = f"{self.temp_dir}/sequenceDB"
        gs_to_ts, ts_to_gs = get_translations(self.handler)
        write_fasta(ts_to_gs)
        create_clusterdb(program="mmseqs")
        self.assertTrue(os.path.exists(db_file))

    def test_5_create_clusterdb3(self):
        """Verify unknown program database doesn't get made"""
        # refresh temp_dir (so if anything is there it's guaranteed to be
        # there because of this method
        refresh_tempdir(self.temp_dir)
        db_file = f"{self.temp_dir}/sequenceDB"
        gs_to_ts, ts_to_gs = get_translations(self.handler)
        write_fasta(ts_to_gs)
        # 'unknown' is not a valid program, so db_file shouldn't exist
        create_clusterdb(program="unknown")
        self.assertFalse(os.path.exists(db_file))

    def test_6_phamerate_mmseqs(self):
        """Verify we can phamerate with mmseqs2"""
        refresh_tempdir(self.temp_dir)
        gs_to_ts, ts_to_gs = get_translations(self.handler)
        write_fasta(ts_to_gs)
        create_clusterdb(program="mmseqs")
        phamerate(params=get_program_params("mmseqs"), program="mmseqs")
        # Make sure clustering output file exists
        self.assertTrue(os.path.exists(f"{self.temp_dir}/clusterDB"))

    # TODO: Comment out this test to reduce runtime by several minutes
    #def test_6_phamerate_blast(self):
    #    """Verify we can phamerate with blastclust"""
    #    refresh_tempdir(self.temp_dir)
    #    gs_to_ts, ts_to_gs = get_translations(self.handler)
    #    write_fasta(ts_to_gs)
    #    create_clusterdb(program="blast")
    #    phamerate(params=get_program_params("blast"), program="blast")
    #    # Make sure clustering output file exists
    #    self.assertTrue(os.path.exists(f"{self.temp_dir}/output.txt"))

    def test_7_convert_output1(self):
        """Verify with mmseqs the output gets converted to parseable format"""
        refresh_tempdir(self.temp_dir)
        gs_to_ts, ts_to_gs = get_translations(self.handler)
        write_fasta(ts_to_gs)
        create_clusterdb(program="mmseqs")
        phamerate(params=get_program_params("mmseqs"), program="mmseqs")
        convert_to_parseable(program="mmseqs")
        # Make sure parseable output exists
        self.assertTrue(os.path.exists(f"{self.temp_dir}/output.txt"))

    # TODO: Comment out this test to reduce runtime by several minutes
    #def test_7_convert_output2(self):
    #    """Verify with blast the output stays the same"""
    #    refresh_tempdir(self.temp_dir)
    #    gs_to_ts, ts_to_gs = get_translations(self.handler)
    #    write_fasta(ts_to_gs)
    #    create_clusterdb(program="blast")
    #    phamerate(params=get_program_params("blast"), program="blast")
    #    convert_to_parseable("blast")
    #    # Make sure parseable output exists
    #    self.assertTrue(os.path.exists(f"{self.temp_dir}/output.txt"))

    def test_7_convert_output3(self):
        """Verify with unknown program the output doesn't exist"""
        refresh_tempdir(self.temp_dir)
        gs_to_ts, ts_to_gs = get_translations(self.handler)
        write_fasta(ts_to_gs)
        create_clusterdb(program="unknown")
        phamerate(params=get_program_params("unknown"), program="unknown")
        convert_to_parseable(program="unknown")
        # Make sure parseable output doesn't exist
        self.assertFalse(os.path.exists(f"{self.temp_dir}/output.tx"))

    def test_8_parse_output1(self):
        """Verify we can parse blastclust output properly"""
        refresh_tempdir(self.temp_dir)
        gs_to_ts, ts_to_gs = get_translations(self.handler)
        write_fasta(ts_to_gs)
        create_clusterdb(program="blast")
        phamerate(params=get_program_params("blast"), program="blast")
        convert_to_parseable(program="blast")
        new_phams = parse_output(program="blast")
        # Make sure new_phams is a dictionary with length > 1
        with self.subTest():
            self.assertEqual(type(new_phams), type(dict()))
        with self.subTest():
            self.assertGreater(len(new_phams), 1)

    def test_8_parse_output2(self):
        """Verify we can parse mmseqs output properly"""
        refresh_tempdir(self.temp_dir)
        gs_to_ts, ts_to_gs = get_translations(self.handler)
        write_fasta(ts_to_gs)
        create_clusterdb(program="mmseqs")
        phamerate(params=get_program_params("mmseqs"), program="mmseqs")
        convert_to_parseable(program="mmseqs")
        new_phams = parse_output(program="mmseqs")
        # Make sure new_phams is a dictionary with length > 1
        with self.subTest():
            self.assertEqual(type(new_phams), type(dict()))
        with self.subTest():
            self.assertGreater(len(new_phams), 1)

    def test_8_parse_output3(self):
        """Verify we cannot parse unknown program's output"""
        refresh_tempdir(self.temp_dir)
        gs_to_ts, ts_to_gs = get_translations(self.handler)
        write_fasta(ts_to_gs)
        create_clusterdb(program="unknown")
        phamerate(params=get_program_params("unknown"), program="unknown")
        convert_to_parseable(program="unknown")
        new_phams = parse_output(program="unknown")
        # Make sure new_phams is a dictionary with length 0
        with self.subTest():
            self.assertEqual(type(new_phams), type(dict()))
        with self.subTest():
            self.assertEqual(len(new_phams), 0)

    def test_9_reintroduce_duplicates(self):
        """Verify that we can put de-duplicated GeneIDs back together"""
        refresh_tempdir(self.temp_dir)
        gs_to_ts, ts_to_gs = get_translations(self.handler)
        write_fasta(ts_to_gs)
        create_clusterdb(program="mmseqs")
        phamerate(params=get_program_params("mmseqs"), program="mmseqs")
        convert_to_parseable(program="mmseqs")
        new_phams = parse_output(program="mmseqs")
        re_duped_phams = reintroduce_duplicates(new_phams=new_phams,
                                                trans_groups=ts_to_gs,
                                                genes_and_trans=gs_to_ts)
        # Every list of GeneIDs in re_duped_phams should be at least as long
        # as the same pham in new_phams - most should be somewhat longer
        for key in new_phams.keys():
            with self.subTest():
                self.assertGreaterEqual(len(re_duped_phams[key]),
                                        len(new_phams[key]))

    def test_10_preserve_phams(self):
        """Verify that pham preservation seems to be working - only needs to
        be tested on results from one clustering program, because this
        function doesn't differentiate between clustering programs"""
        old_phams, old_colors = read_existing_phams(self.handler)
        unphamerated = read_unphamerated_genes(self.handler)
        refresh_tempdir(self.temp_dir)
        gs_to_ts, ts_to_gs = get_translations(self.handler)
        write_fasta(ts_to_gs)
        create_clusterdb(program="mmseqs")
        phamerate(params=get_program_params("mmseqs"), program="mmseqs")
        convert_to_parseable(program="mmseqs")
        new_phams = parse_output(program="mmseqs")
        new_phams = reintroduce_duplicates(new_phams=new_phams,
                                           trans_groups=ts_to_gs,
                                           genes_and_trans=gs_to_ts)
        final_phams, new_colors = preserve_phams(old_phams=old_phams,
                                                 new_phams=new_phams,
                                                 old_colors=old_colors,
                                                 new_genes=unphamerated)
        # Final phams should be a dict with same number of keys as new_phams
        # since we aren't re-dimensioning, just renaming some keys
        with self.subTest():
            self.assertEqual(type(final_phams), type(dict()))
        with self.subTest():
            self.assertEqual(len(final_phams), len(new_phams))
        # New colors should be a dict with the same number of keys as
        # final_phams
        with self.subTest():
            self.assertEqual(type(new_colors), type(dict()))
        with self.subTest():
            self.assertEqual(len(new_colors), len(final_phams))
        # Can't compare the keys or phams since there's no guarantee that
        # any of the phams were preserved but we can make sure all genes are
        # accounted for
        genes_1_count = len(unphamerated)
        for key in old_phams.keys():
            genes_1_count += len(old_phams[key])
        genes_2_count = 0
        for key in new_phams.keys():
            genes_2_count += len(new_phams[key])
        with self.subTest():
            self.assertEqual(genes_1_count, genes_2_count)

    # Don't really have a good way to verify that reinsert_pham_data() or
    # fix_miscolored_phams() appear to be working properly, but both functions
    # have undergone rigorous manual checks to make sure the MySQL commands
    # and python code work together to come to the correct output


def refresh_tempdir(dir):
    if os.path.exists(dir):
        rmtree(dir)
    os.makedirs(dir)


def get_program_params(program):
    """
    Argparse-free version of same-named function in phameration.py -
    uses hard-coded default values that are the same for all params
    that overlap between the two supported programs
    :param program: clustering program in ["blast", "mmseqs"]
    :return: params dictionary
    """
    if program == "blast":
        params = {"-S": 40,
                  "-L": float(80)/100,
                  "-a": 4}
    elif program == "mmseqs":
        params = {"--threads": 4,
                  "-v": 3,
                  "--cluster-steps": 2,
                  "--max-seqs": 500,
                  "--min-seq-id": float(40)/100,
                  "-c": float(80)/100,
                  "--alignment-mode": 3,
                  "--cov-mode": 0,
                  "--cluster-mode": 0}
    else:
        print(f"Unrecognized program {program}")
        return dict()

    return params


if __name__ == '__main__':
    unittest.main()
